---
title:  部署到生产环境
toc: false
---

我们前面的代码都是在我们自己的电脑（通常是Windows操作系统）上面运行的，因为我们还处于开发过程中。

当我们完成一个阶段的开发任务后，就需要把我们开发的网站服务，给真正的用户使用了。

那就需要我们的 网站 部署在公网机器上，而不是我们的个人电脑。 这个给真正用户使用的网站服务器我们通常称之为  ```生产环境``` 

通常，我们的web服务是部署在云服务厂商的云主机上，比如阿里云的ECS云主机。当然如果你们公司有自己的机房和公网服务器，当然也可以。

现在的web服务，基本都是采用 Linux 操作系统。 而且生产环境不应该使用 SQLite 数据库，通常是 MySQL、Postgresql、Oracle等。

本章内容就是教大家 如何 在Linux操作系统上安装 我们 网站系统，包括我们的代码和MySQL数据库服务。

首先，需要大家有 Linux 和MySQL的 基础知识。如果你还没有掌握，[点击这里学习白月黑羽的Linux 和MySQL的基础教程](http://www.python3.vip/doc/tutorial/o/linux/01/){:target='_blank/'}


## 架构

一个大型的网站系统，架构通常非常的复杂，包括很多的功能节点。大家可以以后慢慢学习。

当前，我们先从基础的架构学起。

可能你会说，我们前面已经把网站运行起来了呀，现在只需要把系统从 Windows 转移到Linux上了，把SQLite 改为 MySQL就行了吧？

不仅如此，认真学习课程的同学应该记得，我们前面曾经讲过如下两点：

- Django 在生产环境不应该处理静态资源（比如网页、图片等）的请求

  前面是开发阶段，为了是环境搭建容易，我们还是让Django来处理静态资源的请求了。

  在生产环境不能这样做，这里我们使用Nginx来处理静态资源的请求。

- Django 在生产环境 不能直接处理 HTTP请求
  
   Django是 wsgi web application 的框架，它只有一个简单的单线程 wsgi web server。 供调试时使用。性能很低。

   在生产环境必须提供 专业的 wsgi web server，比如 uWSGI 或者 Gunicorn。 我们这里使用 Gunicorn。

   而且即使有了 uWSGI  或者 Gunicorn，我们最好还要在前面设置  Nginx 。所有的客户请求由它先接受，再进行相应的转发。

   为什么要这样？

   Nginx 在整个后端的最前方， 可以实现 负载均衡、反向代理、请求缓存、响应缓存 、负荷控制等等一系列功能。可以大大的提高整个后端的性能和稳定性。


综上， 我们当前这个简单网站，其架构图如下




既然要分页，那么前端发送的请求中需要携带 两个信息：  ```每页包含多少条记录``` 和  ```需要获取第几页``` 

我们定义列出数据请求中 添加 2个url 参数：  ```pagesize```  和  ```pagenum```   分别对应这两个信息。

为了实现分页 和 过滤 ，接口也做了相应的修改，修改后就是的文档：<a target='_blank' href='/doc/tutorial/django/doc_api_v1_2/'>API接口文档1.2, 点击查看</a>

<br>

Django提供了对分页的支持，具体的信息，大家可以<a target='_blank' href='https://docs.djangoproject.com/en/dev/topics/pagination/'>点击这里查看其官方文档 </a>


以列出药品的代码为例， 我们可以修改 listmedicine 函数，如下

```py
# 增加对分页的支持
from django.core.paginator import Paginator, EmptyPage

def listmedicine(request):
    try:
        # 返回一个 QuerySet 对象 ，包含所有的表记录
        qs = Medicine.objects.values()

        # 要获取的第几页
        pagenum = request.params['pagenum']

        # 每页要显示多少条记录
        pagesize = request.params['pagesize']

        # 返回一个 QuerySet 对象 ，包含所有的表记录
        qs = Medicine.objects.values()

        # 使用分页对象，设定每页多少条记录
        pgnt = Paginator(qs, pagesize)

        # 从数据库中读取数据，指定读取其中第几页
        page = pgnt.page(pagenum)

        # 将 QuerySet 对象 转化为 list 类型
        retlist = list(page)
         
        # total指定了 一共有多少数据
        return JsonResponse({'ret': 0, 'retlist': retlist,'total': pgnt.count})

    except EmptyPage:
        return JsonResponse({'ret': 0, 'retlist': [], 'total': 0})

    except:
        return JsonResponse({'ret': 2,  'msg': f'未知错误\n{traceback.format_exc()}'})
```

<br>

注意，我们返回的信息，包括一页的数据， 还需要告诉前端， 符合条件的 ```总共有多少条记录``` 。为什么？

因为这样，前端可以计算出， 总共有多少页，从而正确的显示出分页界面，如下所示

![image](https://user-images.githubusercontent.com/36462795/52028695-e9184400-254a-11e9-8b54-701e4d593750.png)


这行代码 创建了 分页对象，在初始化参数里面设定每页多少条记录

```py
pgnt = Paginator(qs, pagesize)
```

返回的 分页对象 赋值给变量 pgnt。

然后：

一页的数据 就可以通过 pgnt.page(pagenum) 获取。

而总共有多少页，通过 pgnt.count 得到。


好的，我们的代码完成了，大家可以先使用 requests构建前端请求，自己测试一下。

测试代码可以是这样

```py
import  requests,pprint

# 先登陆,获取sessionid
payload = {
        'username': 'byhy',
        'password': '88888888'
    }

response = requests.post("http://localhost/api/mgr/signin",
                             data=payload)

retDict = response.json()

sessionid = response.cookies['sessionid']

# 再发送列出请求，注意多了 pagenum 和 pagesize
payload = {
    'action': 'list_medicine',
    'pagenum': 1,
    'pagesize' : 3
}

response = requests.get('http://localhost/api/mgr/medicines',
              params=payload,
              cookies={'sessionid': sessionid})

pprint.pprint(response.json())
```

我们指定了 每页3条记录，获取第一页

返回结果类似下面这样

```py
{'ret': 0,
 'retlist': [{'desc': '青霉素注射剂', 'id': 1, 'name': '青霉素', 'sn': 'sn345556235'},
             {'desc': '来适可盒装', 'id': 2, 'name': '来适可', 'sn': 'sn886839452'},
             {'desc': '盐酸盐片剂、胶囊', 'id': 3,'name': '环丙沙星','sn': 'Ciprofloxacin'}
            ],
 'total': 15}
```

可以发现，药品总数有 15条记录，按照每页3条记录的话，返回的第一页内容就是retlist里面的信息。

大家可以修改测试代码，获取第2页的内容，对比查看一下。






### 过滤

我们再看过滤如何实现。

过滤 就是 根据用户的提供的筛选条件，只读取符合条件的部分信息。

比如，列出药品，需要根据 药品描述 中包含的关键字来 查询 。

而且用户可能会输入多个关键字， 比如   ```乳酸```  和   ```注射液``` 。 

这就有一个问题， 多个关键字查询 是  ```且```  的关系 还是  ```或```  的关系。 前者要求 药品描述 同时包含 多个关键字， 后者只需 包含其中任意一个关键字即可。

我们这里 先以 ```且```  的关系 为例。


<br>

首先，我们需要在 列出药品的请求消息里面 添加一个参数 保存关键字信息。我们这里使用 keywords 参数。

里面包含的多个关键字之间用  ```空格```  分开。

查询过滤条件，前面我们学过，可以通过 QuerySet 对象的 filter方法， 比如

```py
qs.filter(name__contains='乳酸')
```

注意，上面的  ```name__contains='乳酸'```  表示 name 字段包含乳酸这个关键字。

Django执行该代码是，会转换为下面的SQL条件从句到数据库进行查询

```SQL
WHERE name LIKE '%乳酸%'
```

如果有 多个 过滤条件， 可以继续在后面调用filter方法，比如

```py
qs.filter(name__contains='乳酸').filter(name__contains='注射液')
```

就等价于下面的 SQL条件从句
```sql
WHERE name LIKE '%乳酸%' AND name LIKE '%注射液%'
```

大家注意没有，  多次调用 filter 方法，是一种  ```AND```  关系， 也就是要同时满足这些条件。

如果我们想表示的是  ```OR```  的关系该怎么办呢？

这时候，可以使用 Django 里面提供 的 Q 对象 。 

参考 官方文档 https://docs.djangoproject.com/en/dev/topics/db/queries/#complex-lookups-with-q-objects

了解 Q对象的详细用法

Q 对象 的初始化参数里面 携带 和 filter 语法一致的 条件，比如

```py
from django.db.models import Q
qs.filter(Q(name__contains='乳酸'))
```

如果我们查询的多个过滤条件是  ```或```  的关系，就用 竖线  ```|```  符号 连接多个Q对象，比如

```py
qs.filter( Q(name__contains='乳酸') | Q(name__contains='注射液'))
```

等价于 下面的 SQL条件从句

```sql
WHERE name LIKE '%乳酸%' OR name LIKE '%注射液%'
```

<br>

如果我们查询的多个过滤条件是  ```且```  的关系，就用 & 符号 连接多个Q对象，比如

```py
qs.filter( Q(name__contains='乳酸') & Q(name__contains='注射液'))
```

等价于 下面的 SQL条件从句

```sql
WHERE name LIKE '%乳酸%' OR name LIKE '%注射液%'
```

---

了解了上的知识，那么我们继续修改  listmedicine 函数，如下所示

```py
def listmedicine(request):
    try:
        # .order_by('-id') 表示按照 id字段的值 倒序排列
        # 这样可以保证最新的记录显示在最前面
        qs = Medicine.objects.values().order_by('-id')

        # 查看是否有 关键字 搜索 参数
        keywords = request.params.get('keywords',None)
        if keywords:
            conditions = [Q(name__contains=one) for one in keywords.split(' ') if one]
            query = Q()
            for condition in conditions:
                query &= condition
            qs = qs.filter(query)

        # 要获取的第几页
        pagenum = request.params['pagenum']

        # 每页要显示多少条记录
        pagesize = request.params['pagesize']

        # 使用分页对象，设定每页多少条记录
        pgnt = Paginator(qs, pagesize)

        # 从数据库中读取数据，指定读取其中第几页
        page = pgnt.page(pagenum)

        # 将 QuerySet 对象 转化为 list 类型
        retlist = list(page)

        # total指定了 一共有多少数据
        return JsonResponse({'ret': 0, 'retlist': retlist,'total': pgnt.count})

    except EmptyPage:
        return JsonResponse({'ret': 0, 'retlist': [], 'total': 0})

    except:
        return JsonResponse({'ret': 2,  'msg': f'未知错误\n{traceback.format_exc()}'})

```
<br>

其中 下面这段代码
```py
            query = Q()
            for condition in conditions:
                query &= condition
            qs = qs.filter(query)
```

我们先构建一个空Q对象 ， 表示没有任何过滤条件， 然后 循环取出过滤关键字， 使用 &  叠加过滤条件。

最后 query 就是 多个 过滤条件 同时满足 的 Q 对象

如果我们想 构建 或 的关系， 就应该这样

```py
query |= condition
```

<br>

好的，我们可以修改测试代码，加上过滤条件，再测试一下

```py
import  requests,pprint

payload = {
        'username': 'byhy',
        'password': '88888888'
    }

response = requests.post("http://localhost/api/mgr/signin",
                             data=payload)

retDict = response.json()

sessionid = response.cookies['sessionid']

# 再发送列出请求，注意多了 keywords
payload = {
    'action': 'list_medicine',
    'pagenum': 1,
    'pagesize' : 3,
    'keywords' : '乳酸 注射液'
}

response = requests.get('http://localhost/api/mgr/medicines',
              params=payload,
              cookies={'sessionid': sessionid})

pprint.pprint(response.json())
```


<br>

这里我们加上 删除订单的代码，如下

```py
def deleteorder(request):
    # 获取订单ID
    oid = request.params['id']

    try:

        one = Order.objects.get(id=oid)
        with transaction.atomic():

            # 一定要先删除 OrderMedicine 里面的记录
            OrderMedicine.objects.filter(order_id=oid).delete()
            # 再删除订单记录
            one.delete()

        return JsonResponse({'ret': 0, 'id': oid})

    except Order.DoesNotExist:
        return JsonResponse({
            'ret': 1,
            'msg': f'id 为`{oid}`的订单不存在'
        })

    except:
        err = traceback.format_exc()
        return JsonResponse({'ret': 1, 'msg': err})
```

### 集成前端

我们的前端开发人员也没有闲着，他们根据接口的变动，修改代码的同时，也大大的修改了一下界面，如下。

是不是好看很多了 ：）

![image](https://user-images.githubusercontent.com/36462795/52105801-248a3f80-262b-11e9-93a9-e4534c6ed26a.png)


等他们完成并发布了前端代码，就可以和我们的后端代码集成在一起发布了 ：）


<br>

目前为止，我们系统的完整代码（包括前端发布的更新），[点击这里下载](https://github.com/baiyueheiyu/fileshare/raw/master/webdev/bysms_12.zip)





<br>

## 作业和练习

学习教程，体会分页和过滤的作用。

掌握教程内容后，不要看教程代码，在上次作业代码的基础上，根据新的接口文档， 在处理列出药品、客户、订单时，加入 ```分页``` 和 ```过滤``` 的功能。


{% include sharepost.html %}


[上一页](/doc/tutorial/django/14/){: .btn .btn--primary .align-left }
[下一页](/doc/tutorial/django/15/){: .btn .btn--primary .align-right }





