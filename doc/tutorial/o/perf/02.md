---
title: 使用场景
---


## 测试场景需要登录

我们做性能测试的时候，模拟的用户使用场景经常需要登录，才能进行后续http请求。

这样的情况下用 黑羽压测 怎么模拟呢？

这个，要看被测系统的用户认证机制。

典型的有下面两种机制。

<br>

###  cookie session 机制

如果 被测系统 使用的是 传统的 session机制。 登录后，服务端会在响应消息的cookie中存入sessionid。客户端后续的请求必须在cookie头中携带sessionid。

这种机制 在 白月黑羽教程中有 详细解释 ，可以[参考这里](http://www.python3.vip/doc/tutorial/django/09/#session-%E6%96%B9%E6%A1%88){:target='_blank/'}


这样的场景，非常简单，因为 黑羽压测 的客户端 会自动保存 服务端返回 的所有cookie，并且会在后续请求中携带上。 也就是说不需要我们做任何 特别的设置。


下面提供了一个示例：

```py
# 创建客户端     
client = HttpClient('127.0.0.1', # 目标地址:端口
                    timeout=10   # 超时时间，单位秒) 

# 登录， 成功后的cookie会自动保存在client对象里                     
response = client.sendAndRecv(
    'POST',
    "/api/mgr/signin",
    data={
        'username':'byhy',
        'password':'88888888'
    })

# 后续请求自动携带cookie里面的sessionid
response = client.sendAndRecv(
    'GET',         
    "/api/path1",
    )
```

<br>

### 消息头中的token机制

如果 被测系统 使用的是 token 机制。 登录后，服务端通常会在响应消息头 中存入token。客户端后续的请求必须在指定头中携带token。

黑羽压测 可以方便的从 响应消息中提取 内容， 并且在后续请求消息中存入。

下面提供了一个示例：

```py
# 创建客户端     
client = HttpClient('127.0.0.1', # 目标地址:端口
                    timeout=10   # 超时时间，单位秒
                       ) 

# 登录， 成功后，token通常在响应消息的消息头中
# 本例中，token所在的消息头名为 jwt
response = client.sendAndRecv(
    'POST',
    "/api/mgr/signin",
    data={
        'username':'byhy',
        'password':'88888888'
    })

# 获取消息头jwt值
jwt = response.getheader('jwt')  

# 后续发送请求，需要在消息头jwt中携带响应中的值
response = client.sendAndRecv(
    'GET',
    "/api/path1",
    # 消息头依次写在下面
    headers={
        'jwt':jwt
    })

```


{% include sharepost.html %}

<br>

[下一页](/doc/tutorial/o/mysql/02/){: .btn .btn--primary .align-center }