---
title: 使用场景
---


## 登录

我们做性能测试的时候，模拟的用户使用场景经常需要登录，才能进行后续http请求。

这样的情况下用 黑羽压测 怎么模拟呢？

这个，要看被测系统的用户认证机制。

典型的有下面两种机制。

<br>

###  cookie session 机制

如果 被测系统 使用的是 传统的 session机制。 登录后，服务端会在响应消息的cookie中存入sessionid。客户端后续的请求必须在cookie头中携带sessionid。

这种机制 在 白月黑羽教程中有 详细解释 ，可以[参考这里](http://www.python3.vip/doc/tutorial/django/09/#session-%E6%96%B9%E6%A1%88){:target='_blank/'}


这样的场景，非常简单，因为 黑羽压测 的客户端 会自动保存 服务端返回 的所有cookie，并且会在后续请求中携带上。 也就是说不需要我们做任何 特别的设置。


下面提供了一个示例：

```py
# 创建客户端     
client = HttpClient('127.0.0.1', # 目标地址:端口
                    timeout=10   # 超时时间，单位秒) 

# 登录， 成功后的cookie会自动保存在client对象里                     
response = client.sendAndRecv(
    'POST',
    "/api/mgr/signin",
    data={
        'username':'byhy',
        'password':'88888888'
    })

# 后续请求自动携带cookie里面的sessionid
response = client.sendAndRecv(
    'GET',         
    "/api/path1",
    )
```

<br>

### token机制

如果 被测系统 使用的是 token 机制。 登录后，服务端通常会在响应消息头 中存入token。客户端后续的请求必须在指定头中携带token。

黑羽压测 可以方便的从 响应消息中提取 内容， 并且在后续请求消息中存入。

下面提供了一个示例：

```py
# 创建客户端     
client = HttpClient('127.0.0.1', # 目标地址:端口
                    timeout=10   # 超时时间，单位秒
                       ) 

# 登录， 成功后，token通常在响应消息的消息头中
# 本例中，token所在的消息头名为 jwt
response = client.sendAndRecv(
    'POST',
    "/api/mgr/signin",
    data={
        'username':'byhy',
        'password':'88888888'
    })

# 获取消息头jwt值
jwt = response.getheader('jwt')  

# 后续发送请求，需要在消息头jwt中携带响应中的值
response = client.sendAndRecv(
    'GET',
    "/api/path1",
    # 消息头写在下面字典中
    headers={
        'jwt':jwt
    })
```


## 检查响应中的数据

性能测试，我们不能只是检查是否收到了响应就行了。

我们还需要检查响应消息对不对。

要检查HTTP响应消息是否正确，就是检查 ```各个部分``` 是否正确，比如状态码、响应消息头、消息体等等。

这些 黑羽压测 有响应的自动代码生成条目， 如下


比如，你要检查响应消息的状态码，如下图箭头处，点击  ```查看响应状态码``` 

![image](https://user-images.githubusercontent.com/36462795/61468496-f9fd2a80-a9af-11e9-9435-aad0e869b2a9.png)

会自动产生 代码行
```py
print(f"响应状态码为 {response.status} ") 
```

我们就知道了 response.status 就是从响应中获取状态码的。

所以我们就可以写出如下代码

```py
# 创建客户端     
client = HttpClient('127.0.0.1',
                    timeout=10
                       ) 

# 发送请求
response = client.sendAndRecv(
    'GET',
    "/api/mgr/signin")

# 检查状态码，必须是200
if (response.status != 200):
    print('状态码不是200，本次操作无法继续')
    # 汇报错误，加入统计结果中
    response.reportError()

# 后续代码
```



## 前后消息数据关联

模拟性能测试的过程中，经常需要将 前面一个响应消息的一些数据 进行处理传入到后续的请求中。

比如，一个API消息 /getopcode  ，响应消息体是 json格式，如下

```py
{
    "opcode" : "25ea6534y6sdef"
}
```

下一条 API 消息 /bugdevice，  是 json格式的消息体，如下， 

```py
{
    "opcode-md5" : "3223sdfsdf23202304",
    "action"  : 'bug_sword'
}
```

其中 opcode-md5 是 前面返回的 opcode值的md5结果。

该怎么办呢？

<br>

同样，如下图所示，点击红色箭头处  ```查看消息体json格式``` 

![image](https://user-images.githubusercontent.com/36462795/61469490-ddfa8880-a9b1-11e9-8a43-8dd3a4ae7c40.png)

会自动产生 蓝色代码行，如下
```py
pprint(response.json('utf8'))
```

我们就知道了 response.json('utf8') 就是从响应中获取json格式消息体内容的（转化为对应的Python数据对象）。

所以我们就可以写出如下代码

```py
# 导入产生md5的库
import hashlib
m = hashlib.md5()

# 创建客户端     
client = HttpClient('127.0.0.1',
                    timeout=10
                       ) 

# 发送请求1
response = client.sendAndRecv(
    'GET',
    "/getopcode")

# 获取opcode        
opcode = response.json('utf8')['opcode']

# 传入md5源数据
m.update(opcode.encode())
# 产生哈希值的十六进制表示
opcode-md5= m.hexdigest()

# 发送请求2
response = client.sendAndRecv(
    'POST',
    "/bugdevice",
    json={
        'opcode-md5':opcode-md5,
        'action':'bug_sword'
    })
```




<br><br><br><br>

{% include sharepost.html %}

<br>

[下一页](/doc/tutorial/o/mysql/02/){: .btn .btn--primary .align-center }